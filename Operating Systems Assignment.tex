\documentclass{article}

\usepackage{listings}
\usepackage{xcolor}

\usepackage[style=authoryear]{biblatex}
\addbibresource{Operating Systems Assignment.bib}

\usepackage{hyperref}

% https://tex.stackexchange.com/questions/116534/lstlisting-line-wrapping
\lstset{
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\title{KV5002 Assignment}
\author{w20013000}
\date{}

\begin{document}

\maketitle

\section{OS Theory}

\subsection{What is a multiprocessing system?}
A multiprocessing system uses two or more physical processor cores that
can each execute distinct code simultaneously. (\cite{silberschatz_operating_2018})

    \subsubsection{Examples}
    Many modern web browsers, such as Google Chrome. run each tab
    in its own process. The advantages of this approach include providing
    "better performance, security, and reliability for your browser tabs" (\cite{parmar_microsoft_2020})
    While multiprocessing is not the primary goal of this,
    it allows for multiple tabs to execute code simultaneously.

    \subsubsection{Benefits}

    \begin{enumerate}
        \item A multiprocessing system is more scalable as it is easier
              and more power efficient to add additional CPU cores than
              it is to increase the performance of individual cores.
        \item An application utilizing multithreading is likely to perform
              better than a single-threaded application as modern CPUs are
              designed with many cores. A multithreaded application can use
              multiple of these cores at a time for different tasks to avoid
              being bottlenecked by a single task.
        \item A multiprocessing system can be more responsive. For example,
              if a thread is dedicated to updating the user interface,
              then the UI will remain responsive even if other threads are
              performing a long task such as accessing a file.
    \end{enumerate}

\subsection{The difference between a process and a thread?}
A process is an instance of a program currently running on the system.
A thread, meanwhile, is the smallest unit of execution scheduled by the operating system.
Each thread belongs to a process, and each process has one or more threads.

Different threads within the same process share the same memory which includes any
statically or dynamically allocated variables. Each thread has its own stack and registers
which store local variables.
Different processes have separate memory spaces, even if they are running the same program.

A process that requires multiprocessing will typically create multiple threads
rather than multiple processes as creating and communicating between processes is
more expensive than with threads.

    \subsubsection{Scenario 1}
    You're writing a report in Microsoft Office. While you are typing, the text is
    displayed, and spelling and grammar are checked.

    This is an example of a process using multiple threads.
    One thread is responsible for displaying the text, while another thread is responsible
    for checking spelling and grammar in it.

    Both threads need to access the same resource, the text being written, and therefore
    need to be part of the same process to share the same memory space.

    \subsubsection{Scenario 2}
    You're writing a report in Microsoft Office while listening to online music from
    iTunes.

    This is an example of multiple processes. Office and iTunes don't need to share
    memory and are different applications running different code, so they are run as
    separate processes.


\subsection{What is a race condition?}
A race condition occurs when two or more threads attempt to access the same resource,
such as a variable, at the same time. This can result in unexpected behaviour such as
one thread overwriting the value written by another thread while the other thread is
still using the value.

    \subsubsection{What is a mutex?}
    A mutex ensures that only one thread can access a resource at a time.
    Before a thread accesses a shared resource, it must first lock the mutex associated with it.
    If the mutex is already locked, the thread will wait until it is unlocked.
    Once the thread is finished with the resource, it unlocks the mutex so that other
    threads can access it.

    \subsubsection{What is a semaphore and how does it differ?}
    A semaphore is similar to a mutex, except that it allows one or more threads to hold
    a lock at a time instead of just one. A semaphore is initialised with a value
    that indicates the number of locks that can be held at a time.

    Similar to a mutex, a thread must first lock the semaphore before accessing the shared resource.
    If there are no locks available, the thread will wait until one becomes available.
    The thread then unlocks the semaphore when it is finished with the resource.
    The lock count is decremented by one when the semaphore is locked and incremented
    when it is unlocked.

    Semaphores can be used instead of mutexes when a resource has limited capacity,
    such as with I/O devices, but can still be safely accessed by multiple threads at the same time.

\subsection{What happens during a context switch?}
// TODO: This

\subsection{What is TLS}
// TODO: This
    \subsubsection{How does TLS protect private information?}
    // TODO: This

\section{The Lunar Lander Controller}{
    % https://tex.stackexchange.com/questions/74529/sections-indexed-with-numbers-subsections-with-letters
    \renewcommand{\thesubsection}{\thesection.\alph{subsection}}

    \subsection{Threads and Semaphores in Code}
        The controller uses 5 threads for the following purposes:
        \begin{enumerate}
            \item Display update.
            \item Keyboard input.
            \item Lander communication.
            \item Dashboard communication.
            \item Data logging.
        \end{enumerate}

        \subsubsection{Semaphore and Thread Alternatives}

        As an alternative to using semaphores and threads, the application could instead
        use a single thread that updates every component in sequence. This would eliminate
        the need for semaphores as there would be no possibility of race conditions.

        Additionally, the dashboard thread could be its own process as it only needs to forward data
        from the lander server to the dashboard client, which could be requested by the dashboard controller itself.

        Data logging can not be its own process as it requires data from the user input thread which is
        not sent by any request from the lander server.

        \subsubsection{Advantages and Disadvantages of Threads in the Program}
        Using threads simplifies running different components at different frequencies as each thread can
        sleep for the required amount of time without affecting any of the other threads.

        Additionally, if one thread fails to run, such as the dashboard thread being unable to send data,
        this will not affect any other threads which improves overall stability.

        However, the use of threads makes the program as a whole more complex as any shared variables
        must be protected by semaphores to prevent race conditions.

        While threads have less overhead than processes, they are not free. As a result, the program may
        use more system resources multithreaded than it would if it was single-threaded.

        \subsubsection{User Input Management}

        // TODO: This

    \subsection{Advantages and disadvantages of UDP and TCP}
    // TODO: This

    \subsection{Data Logging}

        \subsubsection{What data is logged and why?}
        All data that is shown on the display is logged. This consists of:
        \begin{itemize}
            \item Log index.
            \item Rotation and thrust commands.
            \item Last input.
            \item Fuel.
            \item Altitude.
            \item Contact state.
            \item Position.
            \item Velocity.
            \item Angle.
            \item Angular velocity.
        \end{itemize}

        The data is logged in the following format:
        \lstinputlisting{sample_log.txt}

        \subsubsection{What are the advantages and disadvantages of logging five times per second?}
        // TODO: This

        \subsubsection{How often would data be logged if not a fixed interval?}
        // TODO: This

        \subsubsection{{What rate does the size of the file grow?}}
        The log file grows at a rate of approximately 1250 bytes per second.
        This was calculated based on a log consisting of 100 entries and having
        a size of 25kb. \mbox{(25000 / 100) * 5 = 1250}
}

\section*{References}

\printbibliography

\section*{Appendix}

\subsection*{controller.c}
\lstinputlisting[language=C]{src/controller.c}

\subsection*{libnet.c}
\lstinputlisting[language=C]{src/libnet.c}

\end{document}
